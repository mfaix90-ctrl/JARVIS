# =============================================================================
# JARVIS v6.1.0 -- WALK-FORWARD ENGINE
# File:   jarvis/walkforward/engine.py
# Version: 1.1.0
# =============================================================================
#
# SCOPE
# -----
# Deterministic rolling-window walk-forward validation.
# Generates train/test splits; applies a caller-supplied evaluation function.
# No randomness. No file I/O. Fully unit-testable.
#
# PUBLIC FUNCTIONS
# ----------------
#   generate_windows(n, train_size, test_size, step) -> List[WalkForwardWindow]
#   run_walkforward(data, train_size, test_size, step, evaluate_fn) -> List[dict]
#
# DETERMINISM CONSTRAINTS
# -----------------------
# DET-01  No stochastic operations.
# DET-02  All inputs passed explicitly.
# DET-03  No side effects. evaluate_fn must be deterministic (caller's responsibility).
# DET-04  No I/O, no logging, no datetime.now().
# =============================================================================

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Sequence


# ---------------------------------------------------------------------------
# DATA MODEL
# ---------------------------------------------------------------------------

@dataclass(frozen=True)
class WalkForwardWindow:
    """
    Single train/test split descriptor.

    Attributes:
        fold:        Zero-based fold index.
        train_start: Inclusive start index of training slice.
        train_end:   Exclusive end index of training slice.
        test_start:  Inclusive start index of test slice.
        test_end:    Exclusive end index of test slice.
    """
    fold:        int
    train_start: int
    train_end:   int
    test_start:  int
    test_end:    int


# ---------------------------------------------------------------------------
# GENERATE WINDOWS
# ---------------------------------------------------------------------------

def generate_windows(
    n:          int,
    train_size: int,
    test_size:  int,
    step:       int,
) -> List[WalkForwardWindow]:
    """
    Generate deterministic rolling walk-forward windows.

    Args:
        n:          Total number of data points.
        train_size: Number of points in each training window.
        test_size:  Number of points in each test window.
        step:       Number of points to advance per fold.

    Returns:
        List of WalkForwardWindow. Empty list when no complete fold fits.

    Raises:
        ValueError if any argument < 1 or train_size + test_size > n.
    """
    if n < 1:
        raise ValueError(f"n must be >= 1; got {n}")
    if train_size < 1:
        raise ValueError(f"train_size must be >= 1; got {train_size}")
    if test_size < 1:
        raise ValueError(f"test_size must be >= 1; got {test_size}")
    if step < 1:
        raise ValueError(f"step must be >= 1; got {step}")

    windows: List[WalkForwardWindow] = []
    fold = 0
    train_start = 0
    while True:
        train_end = train_start + train_size
        test_start = train_end
        test_end = test_start + test_size
        if test_end > n:
            break
        windows.append(WalkForwardWindow(
            fold=fold,
            train_start=train_start,
            train_end=train_end,
            test_start=test_start,
            test_end=test_end,
        ))
        fold += 1
        train_start += step
    return windows


# ---------------------------------------------------------------------------
# RUN WALK-FORWARD
# ---------------------------------------------------------------------------

def run_walkforward(
    data:        Sequence[Any],
    train_size:  int,
    test_size:   int,
    step:        int,
    evaluate_fn: Callable[[Sequence[Any], Sequence[Any]], Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """
    Run deterministic walk-forward validation.

    For each window generated by generate_windows():
        train_slice = data[window.train_start : window.train_end]
        test_slice  = data[window.test_start  : window.test_end]
        result      = evaluate_fn(train_slice, test_slice)

    evaluate_fn must be a pure, deterministic function. Its signature:
        evaluate_fn(train: Sequence[Any], test: Sequence[Any]) -> Dict[str, Any]

    Args:
        data:        Full dataset as a sequence.
        train_size:  Training window size.
        test_size:   Test window size.
        step:        Step size per fold.
        evaluate_fn: Caller-supplied deterministic evaluation function.

    Returns:
        List of dicts, one per fold, each containing:
            'fold':   fold index (int)
            'window': WalkForwardWindow
            **result: all keys from evaluate_fn's return dict
    """
    windows = generate_windows(len(data), train_size, test_size, step)
    results: List[Dict[str, Any]] = []
    for window in windows:
        train_slice = data[window.train_start : window.train_end]
        test_slice  = data[window.test_start  : window.test_end]
        fold_result = evaluate_fn(train_slice, test_slice)
        entry: Dict[str, Any] = {
            "fold":   window.fold,
            "window": window,
        }
        entry.update(fold_result)
        results.append(entry)
    return results


__all__ = [
    "WalkForwardWindow",
    "generate_windows",
    "run_walkforward",
]
